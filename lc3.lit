@code_type c .c
@comment_type /* %s */

@title Write your Own Virtual Machine

@s Introduction

In this tutorial, I will teach you how to write your own virtual machine (VM). If you know how to program, but would like to gain a deeper understanding of what is going on inside a computer and better understand how programming languages work, then this project is for you. Writing your own VM may sound a little scary, but I promise that you will find it to be surprisingly simple and enlightening.

The [final code](lc3.c) is about 250 lines of C. All you need to know is how to read basic C or C++ and how to do arithmetic with binary. A few parts of the code are written specifically for Unix systems (including macOS). They are necessary for running the program but are not important to the tutorial itself. By the end, your VM will be able to run programs such as my friend's [2048](https://github.com/rpendleton/lc3-2048) or my [Roguelike](https://github.com/justinmeiners/lc3-rogue).

> **Note:** This article is a [literate program](https://en.wikipedia.org/wiki/Literate_programming). This means you are reading the source code right now! I will explain each block of code, one at a time, and these will be "woven" together to make the final program. You can be sure that no detail will be left out.

### What is a virtual machine?

A VM is a program that acts like a computer. It simulates a CPU along with a few other hardware components, allowing it to perform arithmetic, read and write to memory, and interact with I/O devices, just like a physical computer. Most importantly, it has its own machine language which you can you can use to program it.

Some VMs are designed to reproduce the behavior of some particular computer. You may have played video game emulators for platforms such as the NES. Most people don't have an NES lying around anymore, but we can still play NES games by simulating the NES hardware in a program.

Other VMs don't act like any real computer and are entirely made up! This is done to make software development easier. A VM is a standard platform which is portable across different hardware configurations. Instead of rewriting a program in different dialects of assembly for each CPU architecture, developers only need to write the small VM program in each assembly language. Each program is then written only once in the VM's assembly language. 

![architecture specific implementation](img/no_vm.gif)

![vm for each architecture](img/vm.gif)

> **Note:** A compiler solves a similar problem by compiling a standard *high-level language* to several CPU architectures. A VM creates a standard *CPU architecture* which is simulated by a program. A compiler has no runtime component while a VM does. Even though compilers do a pretty good job, writing a new one that targets multiple platforms is very difficult, so VMs are still helpful here. In practice, VMs and compilers are mixed at various levels.

The [Java Virtual Machine (JVM)](https://en.wikipedia.org/wiki/Java_virtual_machine) is a very successful example. The JVM itself is a moderately sized program that is small enough for one programmer to understand. This has made it possible to be written for thousands of devices including your phone. Once the JVM is implemented on a new device, any Java/Kotlin/Clojure program ever written can run it without modification. The only cost is the overhead of the VM itself and the [further abstraction](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/) from the machine. Most of the time, this is a pretty good tradeoff. 

Virtual machines are also useful for executing code in a secure or isolated way. One application of this is garbage collection. There [is no trivial way](https://www.lua.org/pil/24.2.html) to implement automatic garbage collection on top of C or C++ since a program cannot see its own stack or variables. However, a VM is “outside” the program it is running and can observe all of the [memory references](https://en.wikipedia.org/wiki/Tracing_garbage_collection) on the stack. 

[Ethereum smart contracts](https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html) also take advantage of this behavior. Smart contracts are small programs which are executed by each validating node in the network. This requires the nodes to run programs on their machines that have been obtained from strangers. To prevent a contract from doing malicious things, contracts are run inside a [VM](http://ethdocs.org/en/latest/introduction/what-is-ethereum.html#ethereum-virtual-machine) which prevents the program from accessing the file system, network, disc, etc. Ethereum is also a good application of the portability features mentioned. While Ethereum nodes can be run on many kinds of computers, the use of a VM allows smart contracts to be written without any consideration of the specific platforms they run on.

@s LC-3 Architecture

For our project, we will be implementing a VM for a fictional computer called the [LC-3](https://en.wikipedia.org/wiki/LC-3). The LC-3 is popular for teaching university students assembly language. It has a simplified instruction set [compared to x86](http://ref.x86asm.net/coder64.html) but contains all the main ideas used in modern CPUs.

> **Note:** This article will not teach you assembly. It is not at all necessary. However, if you are interested, you can write and assemble your own LC-3 programs using the [LC-3 Tools](http://highered.mheducation.com/sites/0072467509/student_view0/lc-3_simulator.html).

First, we need to simulate the essential hardware components of the machine. Try to understand what each component is, but don't worry right now if you are unsure of how it fits into the larger picture. This is explained in [Executing Programs](#Executing_Programs). Start by creating a C file. Each of the code snippets in this section should be placed in the global scope of this file.

### Memory

The LC-3 has 65536 memory locations (the maximum that is addressable by a 16-bit unsigned integer $2^{16}$), each of which stores a 16-bit value. It can store only 128kb which is a lot smaller than you may be used to! In our program this memory will be stored in an array:

--- Memory Storage
/* 65536 locations */
uint16_t memory[UINT16_MAX]; 
---

### Registers

A register is a slot for storing a single value on the CPU. Registers are like the "workbench" of the CPU. For the CPU to work with a piece of data, it has to be in one of the registers. However, since there are only a few registers, only a minimal amount of data can be loaded at any given time. Programs work around this by loading values from memory into registers, calculating values into other registers, and then storing the final results back in memory.

The LC-3 has 10 total registers, each of which is 16 bits. Most of them are general purpose, but a few have designated roles.
- 8 general purpose registers  (`R0`-`R7`)
- 1 program counter (`PC`) register
- 1 condition flags (`COND`) register

The general purpose registers can be used to perform any program calculations. The program counter is an unsigned integer which is the address of the next instruction in memory to execute. The condition flags tell us information about the previous calculation.

--- Registers 
enum
{
    R_R0 = 0,
    R_R1,
    R_R2,
    R_R3,
    R_R4,
    R_R5,
    R_R6,
    R_R7,
    R_PC, /* program counter */
    R_COND,
    R_COUNT
};
--- 

--- Register Storage
uint16_t reg[R_COUNT];
---

### Condition Flags

The `R_COND` register stores condition flags which give us information about the most recently executed calculation. This allows programs to check logical conditions such as `if (x > 0) { ... }`. 

Different CPUs have a variety of condition flags. The LC-3 uses only 3 condition flags which indicate the sign of the previous calculation. 
--- Condition Flags
enum
{
    FL_POS = 1 << 0, /* P */
    FL_ZRO = 1 << 1, /* Z */
    FL_NEG = 1 << 2, /* N */
};
---

> **Note:** (The `<<` symbol is called the [left bitshift operator](https://msdn.microsoft.com/en-us/library/336xbhcz.aspx). `(n << k)` shifts the bits of `n` to the left `k` places. Read that link if you are not familiar. It will be important.)

### Instructions

An instruction is a command which tells the CPU to do some fundamental task, such as add two numbers. Instructions have both an **opcode** which indicates the kind of task to perform and a set of **parameters** which provide data to the task being performed.

Each **opcode** represents one task that the CPU "knows" how to do. There are just 16 opcodes in LC-3. Everything the computer can calculate is just some sequence of these simple instructions. Each instruction is 16 bits long, with the left 4 bits storing the opcode. The rest of the bits are used to store the parameters.

We will discuss, in detail, what each instruction does later. For now, define the following opcodes. Make sure they stay in this order so that they are assigned the proper enum value:

--- Opcodes
enum 
{
    OP_BR = 0, /* branch */
    OP_ADD,    /* add  */
    OP_LD,     /* load */
    OP_ST,     /* store */
    OP_JSR,    /* jump register */
    OP_AND,    /* bitwise and */
    OP_LDR,    /* load register */
    OP_STR,    /* store register */
    OP_RTI,    /* unused */
    OP_NOT,    /* bitwise not */
    OP_LDI,    /* load indirect */
    OP_STI,    /* store indirect */
    OP_JMP,    /* jump */
    OP_RES,    /* reserved (unused) */
    OP_LEA,    /* load effective address */
    OP_TRAP    /* execute trap */
};
---

> **Note:** The Intel x86 architecture has hundreds of instructions, while others such as ARM have very few like the LC-3. Small instruction sets are referred to as [RISCs](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer) while larger ones are called [CISCs](https://en.wikipedia.org/wiki/Complex_instruction_set_computer). Larger instruction sets are more convenient to write assembly for and require instructions to complete a task but are more complex and expensive for engineers to design and manufacture. There are many other tradeoffs which make the designs come into and out of style.

We are finished setting up the hardware components of our VM! You will need to include some system headers (listed later). Your file should now look something like this:

--- lc3.c
@{Includes}

@{Registers}
@{Condition Flags}
@{Opcodes}
---

@s Executing Programs

Let's now look at an LC-3 assembly program to get an idea of what the VM actually runs. You don't need to understand everything, just have a general idea of what is going on. Here is a simple "Hello World":

--- Hello World Assembly
.ORIG x3000                        ; instruct the computer to load program to this address 
LEA R0, HELLO_STR                  ; load the address of the HELLO_STR string into R0 
PUTs                               ; output the string pointed to by R0 to the console 
HALT                               ; halt the program
HELLO_STR .STRINGZ "Hello World!"  ; store this string here in the program 
---

Just like in C, the program starts at the top and executes one statement at a time. However, unlike in C, there are no scopes `{}` or control structures such as `if` or `while`; just a flat list of statements. Control flow is controlled in a [goto](https://en.wikipedia.org/wiki/Goto) like way. 

Notice that some of the statements correspond to the opcodes we defined earlier. Previously, we learned that every instruction was 16 bits, but each line looks like it is a different number of characters. That is because this code is written in **assembly** which is a human-readable and writable form. A tool called an **assembler** is used to transform each line of text, into a binary 16-bit instruction. This binary form is what the VM actually runs. 

The commands `.ORIG` and `.STRINGZ` look like instructions but they aren't. They are assembler directives which generate some code or data. For example the `.STRINGZ` places a string into the program binary at the location it is written.

PICTURE HERE

To write the VM, you don't need to be fluent in assembly. As long as you follow the proper procedure for reading and executing instructions, *any* LC-3 program will run properly.

> **Note:** If you think about this property deeply, it is a philosophically remarkable idea. The programs themselves can do all kinds of intelligent things that you never anticipated and may not understand, but at the same time, everything they can do is limited to the simple code we will write! We simultaneously know everything and nothing about how each program works.

Here is the procedure we need to write:

1. Load one instruction from memory at the address of the `PC` register. 
2. Increment the `PC` register.
3. Look at the opcode to determine which type of instruction it should perform. 
4. Perform the instruction using the parameters in the instruction.
5. Go back to step 1.

You may be wondering, "if the loop keeps incrementing the `PC`, and we don't have `if` or `while`, won't it quickly run out of instructions?" The answer is no. As we mentioned before, some goto-like instructions change the execution flow by jumping the `PC` around. 

Let's start outlining this process in the main loop:

--- Main Loop

int main(int argc, const char* argv[])
{
    @{Setup}
    @{Load Arguments}

    /* set the PC to starting position */
    /* 0x3000 is the default */
    enum { PC_START = 0x3000 };
    reg[R_PC] = PC_START;

    int running = 1;
    while (running) 
    {
        /* FETCH */
        uint16_t instr = mem_read(reg[R_PC]++);
        uint16_t op = instr >> 12;

        switch (op)
        {
            case OP_ADD:
                @{ADD} 
                break;
            case OP_AND:
                @{AND}
                break;
            case OP_NOT:
                @{NOT}
                break;
            case OP_BR:
                @{BR}
                break;
            case OP_JMP:
                @{JMP}
                break;
            case OP_JSR:
                @{JSR}
                break;
            case OP_LD:
                @{LD}
                break;
            case OP_LDR:
                @{LDR}
                break;
            case OP_LEA:
                @{LEA}
                break;
            case OP_ST:
                @{ST}
                break;
            case OP_STI:
                @{STI}
                break;
            case OP_STR:
                @{STR}
                break;
            case OP_TRAP:
                @{TRAP}
                break;
            case OP_RES:
            case OP_RTI:
            default:
                @{BAD OPCODE}
                break;      
        }
    }
    @{Shutdown}
}
---

@s Implementing Instructions

Your task now is to fill in each opcode case with a proper implementation. A detailed specification for each instruction is included in the project [documents](docs/lc3-isa.pdf). You will need to learn how each instruction works from its specification and write an implementation. This is easier than it sounds. I will demonstrate how to implement two of them here. The code for the rest can be found in the next section.

Two of the opcodes specified will not be needed in this project, they are `OP_RTI` and `OP_RES`. You can ignore these cases or throw an error if they are executed:

--- BAD OPCODE
abort();
---

### ADD 

The `ADD` instruction takes two numbers, adds them together, and stores the result in a register. The specification for it is found on page 526. Each `ADD` instruction looks like the following:

![Encoding](img/add_layout.gif)

The encoding shows two rows because there are actually two different "modes" for this instruction. Before I explain modes, let's look at the parts that are the same. In both rows, we can see that we start with 4 bits, `0001`. This is the opcode value `OP_ADD`. The next 3 bits are marked `DR`. This stands for destination register. This register is where the added sum will be stored. The next 3 bits are `SR1`. This is the register containing the first number to add. 

So we know where we want to store the result and we know the first number to add. Now we need to get the second number to add. However, here the two rows start to look different. Notice that on the top row the 5th bit is a `0` and in the second row it is `1`. This bit indicates whether it is *immediate mode* or *register mode*. In *register mode*, the second number is stored in a register just like the first. This is marked `SR2` and is contained in bits 2-0. Bits 3 and 4 are unused. In assembly this would be written as: 

--- Add Register Assembly
ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.
---

In immediate mode, instead of adding the contents of a register, the value is embedded in the instruction itself. This is convenient because the program doesn't need to load that number into the register in an earlier instruction. Instead, it is right inside the instruction when we need it. The tradeoff is that it can only store a small number $2^{5}=32$ (unsigned) to be exact. This is most useful for incrementing a value. In assembly, it might be written as:

--- Add Immediate Assembly
ADD R0 R0 1 ; add 1 to R0 and store back in R0
---

Here is a summary from the specification:

> If bit [5] is 0, the second source operand is obtained from `SR2`. If bit [5] is 1, the second source operand is obtained by sign-extending the `imm5` field to 16 bits. In either case, the second source operand and the contents of `SR1` are bitwise ANDed, and the result stored in DR. (Pg. 526)

That sounds just like we discussed. But what is "sign-extending"? While the immediate mode value has only 5 bits, it needs to be added to a 16-bit number. For positive numbers, we can just use 0's for the additional bits and the value is the same. However, for negative numbers, this causes a problem. For example, -1 in 5 bits is `1 1111`. If we just add 0's, this is `0000 0000 0001 1111` which is 32. Sign extension prevents this problem by filling in 0's for positive numbers and 1's for negative numbers. 

> **Note:** If you are interested in exactly how negative numbers can be represented in binary. You can read about [Two's Complement](https://en.wikipedia.org/wiki/Two%27s_complement). However, this is not essential. You can just copy the code below and use it when you need to sign extend numbers.
 
--- Sign Extend
uint16_t sign_extend(uint16_t x, int bit_count)
{
    if ((x >> (bit_count - 1)) & 1) {
        x |= (0xFFFF << bit_count);
    }
    return x;
}
---

There is one last sentence in the specification:

> The condition codes are set based on whether the binary value produced, taken as a 2’s complement integer, is negative, zero, or positive. (Pg. 526)

Earlier we defined a condition flags enum, and now it's time to put them to good use. *Any time* a value is written to a register, we need to update the flags to indicate its sign.

--- Update Flags
void update_flags(uint16_t r0)
{
    if (reg[r0] == 0)
    {
        reg[R_COND] = FL_ZRO;
    }
    else if (reg[r0] >> 15) /* a 1 in the left-most bit indicates negative */
    {
        reg[R_COND] = FL_NEG;
    }
    else
    {
        reg[R_COND] = FL_POS;
    }  
}
---

This section contained a lot of information, so let's summarize.
- ADD takes two values and stores them in a register.
- In register mode, the second value to add is in a register.
- In immediate mode, the second value is embedded in the right-most 5 bits of the instruction.
- Values which are smaller than 16 bits need to be sign extended.
- Any time an instruction modifies a register, the condition flags need to be updated.

Now we are ready to write the code for the `ADD` case:

--- ADD
{
    /* destination register (DR) */
    uint16_t r0 = (instr >> 9) & 0x7;
    /* first operand (SR1) */
    uint16_t r1 = (instr >> 6) & 0x7;
    /* whether we are in immediate mode */
    uint16_t imm_flag = (instr >> 5) & 0x1;

    if (imm_flag)
    {
        uint16_t imm5 = sign_extend(instr & 0x1F, 5);
        reg[r0] = reg[r1] + imm5;
    }
    else
    { 
        uint16_t r2 = instr & 0x7;
        reg[r0] = reg[r1] + reg[r2];
    }

    update_flags(r0);
}
---

You may be feeling overwhelmed about writing 15 more instructions. However, all of what you learned here will be reused. Most of the instructions use some combination of sign extension and different modes, and then update flags.

### LDI 

`LDI` stands for "load indirect." This instruction is used to load a value from a location in memory into a register. The specification is found on page 532.

Here is what it looks like:

![Encoding](img/ldi_layout.gif)

In contrast to `ADD`, there are no modes and fewer parameters. This time, the opcode is `1010` which corresponds with the `OP_LDI` enum value. Just like in `ADD`, we have a 3-bit `DR` (the destination register) for storing the loaded value. The remaining bits are labeled `PCoffset9`. This is an immediate value embedded in the instruction (similar to `imm5`). Since this instruction loads from memory, we can guess that this number is some kind of address which tells us where to load from. The specification provides more detail:

> An address is computed by sign-extending bits [8:0] to 16 bits and adding this value to the incremented `PC`. What is stored in memory at this address is the address of the data to be loaded into `DR`. (Pg. 532)

Just like before, we need to sign extend this 9-bit value and then add it to the current `PC`. (If you look back at the execution loop, the `PC` was incremented right after this instruction was loaded.) The resulting sum is an address to a location in memory, and that address *contains, yet another* value which is the address of the value to load.

Let's look at an example:

While the following may seem like a roundabout way to read from memory, it may be necessary at times. The `LD` instruction is limited to address offsets that are 9 bits, whereas the memory requires 16 bits to address. `LDI` is useful for loading values that are stored in locations far away from the current PC, but to use it, the address of the final location needs to be stored in a neighborhood nearby. You can think of it like having a local variable which is a pointer to some data.

--- LDI Assembly
; char* far_data = ...; // local variable containing a pointer to some far away data

LDI R0 DATA_ADDRESS
; ...
; near in memory...
DATA_ADDRESS .FILL DATA
; ...
; far away in memory...
DATA .STRINGZ "Hello World!"
---

Same as before, we need to update flags after putting the value into `DR`:

> The condition codes are set based on whether the value loaded is negative, zero, or positive. (Pg. 532)

Here is the code for this case:
--- LDI
{
    /* destination register (DR) */
    uint16_t r0 = (instr >> 9) & 0x7;
    /* PCoffset 9*/
    uint16_t pc_offset = sign_extend(instr & 0x1ff, 9);
    /* add pc_offset to the current PC, look at that memory location to get the final address */
    reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset));
    update_flags(r0);
}
---

(We discuss `mem_read` soon in a later section.)

As I said, this instruction shared a lot of the code and knowledge learned from `ADD`. You will find this is the case with the remaining instructions.

You now need to go back and implement the rest of the switch cases for the instructions. Follow the specification and use the code listed here to complete the others. The code for all instructions is listed at the end of the tutorial. After you are done, the bulk of your VM will be completed!

@s Full Instructions 

This section contains the full implementations of the remaining instructions.

### [Bitwise and](https://en.wikipedia.org/wiki/Bitwise_operation#AND)
--- AND
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t r1 = (instr >> 6) & 0x7;
    uint16_t imm_flag = (instr >> 5) & 0x1;

    if (imm_flag)
    {
        uint16_t imm5 = sign_extend(instr & 0x1F, 5);
        reg[r0] = reg[r1] & imm5;
    }
    else
    {
        uint16_t r2 = instr & 0x7;
        reg[r0] = reg[r1] & reg[r2];
    }
    update_flags(r0);
}
---

### [Bitwise not](https://en.wikipedia.org/wiki/Bitwise_operation#NOT)
--- NOT
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t r1 = (instr >> 6) & 0x7;

    reg[r0] = ~reg[r1];
    update_flags(r0);
}
---
### Branch
--- BR
{
    uint16_t pc_offset = sign_extend((instr) & 0x1ff, 9);
    uint16_t cond_flag = (instr >> 9) & 0x7;
    if (cond_flag & reg[R_COND])
    {
        reg[R_PC] += pc_offset;
    }
}
---
### Jump

`RET` is listed as a separate instruction in the specification, since it is a different keyword in assembly. However, it is actually a special case of `JMP`. `RET` happens whenever `R1` is 7.
--- JMP
{
    /* Also handles RET */
    uint16_t r1 = (instr >> 6) & 0x7;
    reg[R_PC] = reg[r1];
}
---
### Jump Register
--- JSR
{
    uint16_t r1 = (instr >> 6) & 0x7;
    uint16_t long_pc_offset = sign_extend(instr & 0x7ff, 11);
    uint16_t long_flag = (instr >> 11) & 1;

    reg[R_R7] = reg[R_PC];
    if (long_flag)
    {
        reg[R_PC] += long_pc_offset;  /* JSR */
    }
    else
    {
        reg[R_PC] = reg[r1]; /* JSRR */
    }
    break;
}
---
### Load
--- LD
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t pc_offset = sign_extend(instr & 0x1ff, 9);
    reg[r0] = mem_read(reg[R_PC] + pc_offset);
    update_flags(r0);
}
---
### Load Register
--- LDR
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t r1 = (instr >> 6) & 0x7;
    uint16_t offset = sign_extend(instr & 0x3F, 6);
    reg[r0] = mem_read(reg[r1] + offset);
    update_flags(r0);
}
---
### Load Effective Address
--- LEA
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t pc_offset = sign_extend(instr & 0x1ff, 9);
    reg[r0] = reg[R_PC] + pc_offset;
    update_flags(r0);
}
--- 
### Store
--- ST
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t pc_offset = sign_extend(instr & 0x1ff, 9);
    mem_write(reg[R_PC] + pc_offset, reg[r0]);
}
---
### Store Indirect
--- STI
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t pc_offset = sign_extend(instr & 0x1ff, 9);
    mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);
}
---
### Store Register
--- STR
{
    uint16_t r0 = (instr >> 9) & 0x7;
    uint16_t r1 = (instr >> 6) & 0x7;
    uint16_t offset = sign_extend(instr & 0x3F, 6);
    mem_write(reg[r1] + offset, reg[r0]);
}
---

@s Trap Routines

A trap code is a like an opcode for a routine that performs a special task such as interacting with an I/O device. These include getting input from the keyboard and displaying strings to the console. The trap routines are provided by the system and act like a very simple operating system for the LC-3.

--- TRAP Codes
enum
{
    TRAP_GETC = 0x20,  /* get character from keyboard */
    TRAP_OUT = 0x21,   /* output a character */
    TRAP_PUTS = 0x22,  /* output a word string */
    TRAP_IN = 0x23,    /* input a string */
    TRAP_PUTSP = 0x24, /* output a byte string */
    TRAP_HALT = 0x25   /* halt the program */
};
---
The trap codes are called like an instruction in assembly, but they are actually composed of other instructions. In the official LC-3 simulator trap routines are [written in assembly](docs/os.asm), just like a regular program. When a trap code is called the `PC` is moved to that codes address. The CPU executes instructions of the proced, and when it is complete the PC is returned to the location it was called from. 

> **Note:** This is why programs start at address `0x3000`. The lower addresses are left empty to leave space for the trap routines.

The assembly trap routines are a good simulation of what a physically constructed LC-3 computer would do, but it isn't the best fit for a VM. Instead of implementing rudimentary I/O routines from scratch, we want to expose the ones that are already available on our OS. This will make the VM run better on our computers, simplify the code, and provide a higher level of abstraction for portability.

There is no specification for *how* trap routines must be implemented, just what they are supposed to do. So, we will write ours in C. When a trap code is called, a C function will be called, and when it is completed, execution will return to the program.

In the switch case form the `TRAP` opcode, add another switch:

--- TRAP
switch (instr & 0xFF)
{
    case TRAP_GETC:
        @{TRAP GETC}       
        break;
    case TRAP_OUT:
        @{TRAP OUT}
        break;
    case TRAP_PUTS:
        @{TRAP PUTS}
        break;
    case TRAP_IN:
        @{TRAP IN}
        break;
    case TRAP_PUTSP:
        @{TRAP PUTSP}
        break;
    case TRAP_HALT:
        @{TRAP HALT}
        break;
}
---

As with instructions, I will show you how to implement a single TRAP and leave the rest to you.

### PUTS

The `PUTS` trap code is used to output a null-terminated string (similar to `printf` in C). The specification is found on page 543.

To display a string, we must give the trap routine a string to display. This is done by storing the address of the first character in `R0` before beginning the trap.

The specification says:

> Write a string of ASCII characters to the console display. The characters are contained
> in consecutive memory locations, one character per memory location, starting with the address specified in R0. Writing terminates with the occurrence of `x0000` in a memory location. (Pg. 543)

Notice that unlike C strings, characters are *not stored* in a single byte, but in a single memory location. Memory locations in LC-3 are 16 bits, so each character in the string is 16 bits wide. To display this with a C function, we will need to convert each value to a char and output them individually.

--- TRAP PUTS
{
    /* one char per word */
    uint16_t* c = memory + reg[R_R0];
    while (*c)
    {
        putc((char)*c, stdout);
        ++c;
    }
    fflush(stdout);
}
---

That's all for this routine. The trap routines are pretty straightforward. Go back to the specification and implement the others now. As with the instructions, the full code can be found at the end of the tutorial.

@s All Trap Routines

This section contains the full implementations of the remaining trap routines.

Input Character
--- TRAP GETC
/* read a single ASCII char */
reg[R_R0] = (uint16_t)getchar(); 
---

Output Character
--- TRAP OUT
putc((char)reg[R_R0], stdout);
fflush(stdout);
---

Prompt for Input Character
--- TRAP IN
printf("Enter a character: ");
reg[R_R0] = (uint16_t)getchar();
---

Output String
--- TRAP PUTSP
{
    /* one char per byte (two bytes per word)
       here we need to swap back to 
       big endian format */
    uint16_t* c = memory + reg[R_R0];
    while (*c)
    {
        char char1 = (*c) & 0xFF;
        putc(char1, stdout);
        char char2 = (*c) >> 8;
        if (char2) putc(char2, stdout);
        ++c;
    }
    fflush(stdout);
}
---

Halt Program
--- TRAP HALT
puts("HALT");
fflush(stdout);
running = 0; 
---

@s Loading Programs

We have talked a lot about loading and executing instructions from memory, but how do instructions get into memory in the first place? When an assembly program is converted to machine code, the result is a file containing an array of instructions and data. This can be loaded by just copying the contents right into an address in memory.

The first 16 bits of the program file specify the address in memory where the program should start. This address is called the **origin**. It must be read first, after which the rest of the data can be read from the file into memory starting at the origin address.

Here is the code for reading an LC-3 program file:

--- Read Image File
void read_image_file(FILE* file)
{
    /* the origin tells us where in memory to place the image */
    uint16_t origin;
    fread(&origin, sizeof(origin), 1, file);
    origin = swap16(origin);

    /* we know the maximum file size so we only need one fread */
    uint16_t max_read = UINT16_MAX - origin;
    uint16_t* p = memory + origin;
    size_t read = fread(p, sizeof(uint16_t), max_read, file);

    /* swap to little endian */
    while (read-- > 0)
    {
        *p = swap16(*p); 
        ++p;
    }
}
---

Notice that `swap16` is called on each of the values that are loaded. LC-3 programs are big-endian, but most of the modern computers we use are little endian. As a result, we need to swap each `uint16` that is loaded. (If you happen to be using an odd computer, like a PPC then you should not swap.)

--- Swap
uint16_t swap16(uint16_t x)
{
    return (x << 8) | (x >> 8);
}
---
> **Note:** [Endianness](https://en.wikipedia.org/wiki/Endianness) refers to how bytes of an integer are interpreted. In little-endian, the first byte is the least significant digit, and in big-endian, it is reversed. As far as I know, the decision is *mostly* arbitrary. Different companies made different decisions, so now we are left with varying implementations. You do not need to know anything else about endianness for this project.

@s Memory Mapped Registers

Some special registers are not accessible from the normal register table. Instead, a special address is reserved for them in memory. To read and write to these registers, you just read and write to their memory location. These are called **memory mapped registers**. They are commonly used to interact with special hardware devices.

The LC-3 has two memory mapped registers that we will implement. They are the keyboard status register (`KBSR`) and keyboard data register (`KBDR`). The `KBSR` indicates whether a key has been pressed, and the `KBDR` indicates which specific key was pressed.

Although you can request keyboard input using `GETC`, this blocks execution until input is received. `KBSR` and `KBDR` allows you to [poll the state](https://en.wikipedia.org/wiki/Polling_(computer_science)) of the device and continue execution, so the program can stay responsive while waiting for input.

--- Memory Mapped Registers
enum
{
    MR_KBSR = 0xFE00, /* keyboard status */
    MR_KBDR = 0xFE02  /* keyboard data */
};
---

Memory mapped registers make memory access a bit more complicated. We can't read and write to the memory array directly, but must instead call setter and getter functions. When memory is read from `KBSR`, it will check the keyboard and update both memory locations.

--- Memory Access
void mem_write(uint16_t address, uint16_t val)
{
    memory[address] = val;
}

uint16_t mem_read(uint16_t address)
{
    if (address == MR_KBSR)
    { 
        if (check_key()) 
        {
            memory[MR_KBSR] = (1 << 15);
            memory[MR_KBDR] = getchar();
        }
        else
        {
            memory[MR_KBSR] = 0;
        }
    }
    return memory[address];
}
---

That completes the last component of the VM! Provided that you implemented the rest of the trap routines and instructions, you are almost ready to try it out!

All that we have written should have been added to the C file.

--- lc3.c +=
@{Memory Mapped Registers}
@{TRAP Codes} 

@{Memory Storage}
@{Register Storage}

@{Functions}

@{Main Loop}
---

@s Platform Specific Details

This section contains some tedious details that we need to access the keyboard and behave nicely. These are not insightful or relevant to learning about VMs. Feel free to copy paste!

If you are trying to run the VM on a non-Unix operating system, such as Windows, these functions need to be replaced with Windows-specific versions.

--- Check Key
uint16_t check_key() 
{
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    return select(1, &readfds, NULL, NULL, &timeout) != 0;
}
---

These extract the program path from the program arguments.

--- Load Arguments
if (argc < 2) 
{
    printf("lc3 [image-file1] ...\n"); 
    exit(2);
}

for (int j = 1; j < argc; ++j)
{
    if (!read_image(argv[j]))
    {
        printf("failed to load image: %s\n", argv[j]);
        exit(1);
    }  
}
---

This is Unix specific code for setting up terminal input.

--- Input Buffering
struct termios original_tio;

void disable_input_buffering() 
{
    tcgetattr(STDIN_FILENO, &original_tio);
    struct termios new_tio = original_tio;
    new_tio.c_lflag &= ~ICANON & ~ECHO;
    tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
}

void restore_input_buffering() 
{
    tcsetattr(STDIN_FILENO, TCSANOW, &original_tio);
}
---

When the program is interrupted, we want to restore the terminal 
settings back to normal.

--- Handle Interrupt
void handle_interrupt(int signal) 
{
    restore_input_buffering();
    printf("\n");
    exit(-2);
}
---

--- Setup
signal(SIGINT, handle_interrupt);
disable_input_buffering();
---

--- Shutdown
restore_input_buffering();
---

Convenience function for `read_image_file`;

--- Read Image
int read_image(const char* image_path)
{
    FILE* file = fopen(image_path, "rb");
    if (!file) { return 0; };
    read_image_file(file);
    fclose(file);
    return 1;
}
---

--- Functions
@{Sign Extend}
@{Swap}
@{Update Flags}
@{Read Image File}
@{Read Image}
@{Check Key}
@{Memory Access}
@{Input Buffering}
@{Handle Interrupt}
---

--- Includes
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>

#include <sys/time.h>
#include <sys/types.h>
#include <sys/termios.h>
#include <sys/mman.h>
---

@s Running the LC-3

You should now be able to build and run the LC-3 VM.

`lc3-vm 2048.obj`

--- 2048 Example
Control the game using WASD keys.
Are you on an ANSI terminal (y/n)? y
+--------------------------+
|                          |
|                          |
|                          |
|                     2    |
|                          |
|   2                      |
|                          |
|                          |
|                          |
+--------------------------+
---


@s Alternate C++ Technique

This section shows a more advanced way of executing instructions. This section is entirely optional.

Since C++ has powerful compile-time generics, there is an alternative way of implementing the instructions. This method reduces code duplication and is actually closer to how the computer would be wired in hardware.

The idea here is to reuse the steps common to each instruction. For example, several of the instructions use indirect addressing or sign extend a value and add it to the current PC value. Wouldn't it be nice if we could write this code once for all instructions?

--- Instruction C++
template <unsigned op>
void ins(uint16_t instr) 
{
    uint16_t r0, r1, r2, imm5, imm_flag;
    uint16_t pc_plus_off, base_plus_off;

    uint16_t opbit = (1 << op);
    if (0x4EEE & opbit) { r0 = (instr >> 9) & 0x7; }
    if (0x12E3 & opbit) { r1 = (instr >> 6) & 0x7; }
    if (0x0022 & opbit) 
    { 
        r2 = instr & 0x7; 
        imm_flag = (instr >> 5) & 0x1;
        imm5 = sign_extend((instr) & 0x1F, 5);
    }
    if (0x00C0 & opbit) 
    {   // Base + offset
        base_plus_off = reg[r1] + sign_extend(instr & 0x3f, 6); 
    }
    if (0x4C0D & opbit) 
    { 
        // Indirect address
        pc_plus_off = reg[R_PC] + sign_extend(instr & 0x1ff, 9); 
    }
    if (0x0001 & opbit) 
    {  
        // BR
        uint16_t cond = (instr >> 9) & 0x7; 
        if (cond & reg[R_COND]) { reg[R_PC] = pc_plus_off; }
    } 
    if (0x0002 & opbit)  // ADD
    {  
        if (imm_flag) 
        {
            reg[r0] = reg[r1] + imm5;
        } 
        else 
        {
            reg[r0] = reg[r1] + reg[r2]; 
        }
    }
    if (0x0020 & opbit)  // AND
    {  
        if (imm_flag) 
        {
            reg[r0] = reg[r1] & imm5;
        } 
        else 
        {
            reg[r0] = reg[r1] & reg[r2];
        }
    }
    if (0x0200 & opbit) { reg[r0] = ~reg[r1]; } // NOT
    if (0x1000 & opbit) { reg[R_PC] = reg[r1]; } // JMP    
    if (0x0010 & opbit)  // JSR
    { 
        uint16_t long_flag = (instr >> 11) & 1; 
        pc_plus_off = reg[R_PC] +  sign_extend(instr & 0x7ff, 11);
        reg[R_R7] = reg[R_PC]; 
        if (long_flag) 
        {
            reg[R_PC] = pc_plus_off;
        } 
        else 
        {
            reg[R_PC] = reg[r1];
        }
    }

    if (0x0004 & opbit) { reg[r0] = mem_read(pc_plus_off); } // LD
    if (0x0400 & opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI
    if (0x0040 & opbit) { reg[r0] = mem_read(base_plus_off); }  // LDR
    if (0x4000 & opbit) { reg[r0] = pc_plus_off; } // LEA
    if (0x0008 & opbit) { mem_write(pc_plus_off, reg[r0]); } // ST
    if (0x0800 & opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI
    if (0x0080 & opbit) { mem_write(base_plus_off, reg[r0]); } // STR
    if (0x8000 & opbit)  // TRAP
    {
         @{TRAP} 
    }
    //if (0x0100 & opbit) { } // RTI
    if (0x4666 & opbit) { update_flags(r0); }
}
---

--- Op Table
static void (*op_table[16])(uint16_t) = {
    ins<0>, ins<1>, ins<2>, ins<3>, 
    ins<4>, ins<5>, ins<6>, ins<7>, 
    NULL, ins<9>, ins<10>, ins<11>, 
    ins<12>, NULL, ins<14>, ins<15>  
};
---

> **Note:** I learned about this technique from [Bisqwit's NES emulator](https://www.youtube.com/watch?v=QIUVSD3yqqE). 
> If you are interested in emulation, or the NES, I highly recommend his videos.

The rest of the program can use the code we already wrote. The full code is [here](lc3-alt.cpp).

--- lc3-alt.cpp
@{Includes}

@{Registers}
@{Condition Flags}
@{Opcodes}

@{Memory Mapped Registers}
@{TRAP Codes} 

@{Memory Storage}
@{Register Storage}

@{Functions}

int running = 1;
@{Instruction C++}
@{Op Table}

int main(int argc, const char* argv[])
{
    @{Setup}
    @{Load Arguments}

    enum { PC_START = 0x3000 };
    reg[R_PC] = PC_START;

    while (running) 
    {
        uint16_t instr = mem_read(reg[R_PC]++);
        uint16_t op = instr >> 12;
        op_table[op](instr);
    }
    @{Shutdown}
}
---

